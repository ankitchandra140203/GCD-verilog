# GCD verilog
 Implementing GCD of two number on verilog
 ## -> Let's break the code

 ### Inputs and Outputs:
 A and B: These are 8-bit (7:0) inputs representing the two numbers for which GCD needs to be calculated.
 gcd: This is an 8-bit output that will hold the GCD of A and B after the calculation.

 ### Internal Registers and wires:
temp1 and temp2: These are 8-bit registers used to store the input values (A and B) and intermediate results during the GCD calculation.
sub: This is an 8-bit register used to store the difference between temp1 and temp2 in certain states.
clk: This is a single-bit register that acts as a clock signal. It's generated by an always block that toggles its value every 5 time units.
state and next_state: These are 3-bit registers used to store the current state and the next state of a Finite State Machine (FSM) that controls the GCD calculation process.
check_A and stop: These are single-bit wires derived from temp1 and temp2 using combinational logic. check_A indicates if temp1 is greater than temp2, and stop indicates if temp1 is equal to temp2.

### FSM for GCD Calculation:
The code defines a 5-state FSM using the state register and a case statement. The states are:

start: Initial state where the FSM begins.
check: This state compares temp1 and temp2 to determine which number is bigger and sets the next state accordingly.
sub_A: In this state, the difference between temp1 and temp2 is calculated and stored in sub.
sub_B: Similar to sub_A, but the difference between temp2 and temp1 is calculated.
result: This is the final state where the GCD calculation is finished, and temp1 holds the result (GCD).

### Combinational Logic:
The code uses two always @(*) blocks to implement combinational logic.

The first block determines the next_state based on the current state and the values of check_A and stop.
In the check state, if stop is not true (meaning temp1 is not equal to temp2), the next state depends on check_A. If check_A is true, it goes to sub_A, otherwise, it goes to sub_B.
In other states, the next state remains the same.
The second block performs operations based on the current state:
In the check state, it calculates the difference between temp1 and temp2 depending on check_A.
In sub_A and sub_B states, it updates temp1 and temp2 with the difference (sub) respectively.
In other states, it does nothing.

### Output:
The final GCD value is stored in temp1 after the FSM reaches the result state.
The result is assigned to the output gcd.

 
